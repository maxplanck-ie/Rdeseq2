---
title: "deseq2"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 2
    toc_float: true
    df_print: paged
---
# Goals:
* Different steps of a differential gene expression analysis
  * multi-factor design
  * Normalisation: Estimating size factors (has been explained before)
  * Checking for the dispertion (has been explained before)
  * Building up contrasts
  * Make a results table
  * Summarize and extract a list of significant differentially expressed genes
  * Visualize the results
  * LRT vs. Wald test

```{r add libraries, message=FALSE, warning=FALSE, paged.print=FALSE}
# add libraries
.libPaths("/data/manke/processing/RdeseqEnv/R-4.0.3_Rcourse/lib64/R/library")
library("DESeq2")
library("dplyr")
library("tibble")
library("ggplot2")
library("ggrepel")
library("pheatmap")
library("org.Hs.eg.db")
library("UpSetR")
library("tidyr")
```

```{r Get the data directroy, message=FALSE, warning=FALSE}
# Get the data directroy
setwd("/data/processing1/leily/r_course/Rdeseq2/")
data_dir <- paste(getwd(), "data", "myeloma", sep = .Platform$file.sep)
#print(data_dir)

# Read count matrix
# paste(data_dir,"myeloma_counts.tsv", sep = "/")
countdata <- read.table("corrected_counts.tsv", header=TRUE, check.names = TRUE)
#head(countdata)

# Read samplesheet , detects conditions, generate the formula
# paste(data_dir,"myeloma_meta.tsv", sep = "/")
sampleInfo <- read.table( "corrected_meta.tsv", header=TRUE, check.names = TRUE, stringsAsFactor = F)
sampleInfo$celltype <- as.factor(sampleInfo$celltype)
sampleInfo$condition <- as.factor(sampleInfo$condition)
print(sampleInfo)
```

# Building a deseq data set with a multi-factor design:
## factors and designs:
To see nicely visulised slides check: https://docs.google.com/presentation/d/1B9zW1_F-kBqQEu4xqxIJrudYP5DecytYMRR6bY4H6aM/edit?usp=sharing

### The simplest case:
 * one factor with two levels

|samples |condition<factor> |
|:-------|:-----|
|sample1 |cond1 |
|sample2 |cond1 |
|sample3 |cond2 |
|sample4 |cond2 |

Design: 

      ~1+condition (or ~condition)
      = beta0 + beta1 * cond2

This resutls in the coefficient for the intercept and coefficient for the effect of “cond2” (i.e. differences between cond2 vs. cond1).

    [1] "Intercept" (beta0)             "condition_cond2_vs_cond1" (beta1)


This can be shown by dummy variables:

|samples | (Intercept) | condtioncond2 |
|:-------|:----|:----|
|sample1 |1 | 0 |
|sample2 |1 | 0 |
|sample3 |1 | 1 |
|sample4 |1 | 1 |

null hypothesis:

    beta1 = 0

### A complex case:
 * One factor with more than two levels

|samples |condition<factor> |
|:-------|:-----|
|sample1 |cond1 |
|sample2 |cond1 |
|sample3 |cond2 |
|sample4 |cond2 |
|sample5 |cond3 |
|sample6 |cond3 |

      ~1+condition
      = beta0 + beta1 * cond2 + beta2 * cond3
      beta0 = Intercept
      beta1 = condition_cond2_vs_cond1
      beta2 = condition_cond3_vs_cond1
Coefficients:

      [1] "Intercept"              "condition_cond2_vs_cond1" "condition_cond3_vs_cond1" 

Model matrix:

|samples | (Intercept) | condtioncond2 | condtioncond3 |
|:-------|:----|:----|:----|
|sample1 |1 | 0 | 0 |
|sample2 |1 | 0 | 0 |
|sample3 |1 | 1 | 0 |
|sample4 |1 | 1 | 0 |
|sample5 |1 | 0 | 1 |
|sample6 |1 | 0 | 1 |

Null hypothesis:

    cond2 vs cond1
    beta1 = 0

    cond3 vs cond1
    beta2 = 0

    cond2 vs cond3
    beta1 - beta2 = 0

### More complex case:
  * Two factors, with interaction
  
|samples |condition<factor> | treatment<factor> |
|:-------|:-----|:-----|
|sample1 |cond1 |treat1|
|sample2 |cond1 |treat1|
|sample3 |cond1 |treat2|
|sample4 |cond1 |treat2|
|sample5 |cond2 |treat1|
|sample6 |cond2 |treat1|
|sample7 |cond2 |treat2|
|sample8 |cond2 |treat2|

The formula for the model includes all sources of variation in the data. Thus, it should contain the condition, treatment and the difference as the effect of condtion on the treatment (condtion:treatment)

Design:

    ~1 + condition + treatment + condition:treatment
    = beta0 + beta1 * cond2 + beta2 * treatment2 + beta3 * cond2.treat2
      beta0 = Intercept
      beta1 = condition_cond2_vs_cond1
      beta2 = treatment_treat2_vs_treat1
      beta3 = conditioncond2.treatmenttreat2

Null hypothesis:

    cond2 vs cond1 (treat1) 
    beta1 = 0

    cond2 vs cond1 (treat2)
    beta1 + beta3 = 0

    treat2 vs treat1 (cond1):
    beta2 = 0

    treat2 vs treat1 (cond2):
    beta2 + beta3 = 0

    Interaction:
    beta3 = 0

```{r build the matrix, message=FALSE, warning=FALSE}
d <- as.formula(~celltype + condition + celltype:condition)
dds <- DESeq2::DESeqDataSetFromMatrix(countData = countdata, colData = sampleInfo, design = d)
```

# Estimate size factors
DESeq2 automatically estimates the size factors when performing the differential expression analysis. However, if `estimateSizeFactors()` is called, then DESeq2 will use these values.

To normalize the count data, DESeq2 calculates size factors for each sample using the "median of ratios" method.
```{r estimate size factors, message=FALSE, warning=FALSE}
dds <- estimateSizeFactors(dds)
sizeFactors(dds)
```

# Find the relation between the size factors and the values of the columns:
```{r colsums, message=FALSE, warning=FALSE}
colSums(counts(dds))
```
Larger size factors correspond to the samples with higher sequencing depth. To generate the normalized counts we need to divide the counts by the size factors. This accounts for the differences in sequencing depth between samples.

# compare the raw sum with the normalised ones:
```{r norm colsums, message=FALSE, warning=FALSE}
colSums(counts(dds, normalized=T))
```

# Importance of dispersion during differential expression analysis
DESeq2 uses a measure of variation called dispersion, which accounts for a gene’s variance and mean expression level. Dispersion is calculated by `Var = μ + α*μ^2`, where `α` = dispersion, `Var` = variance, and `μ` = mean
# Estimate dispersion
```{r estimate dispersions, message=FALSE, warning=FALSE}
# To generate more accurate estimates of variation based on the mean expression level of the gene using a method called ‘shrinkage’. DESeq2 assumes that genes with similar expression levels should have similar dispersion. (??)
dds <- estimateDispersions(dds)
```
# Visualise dispersion
```{r Visualise dispersions, message=FALSE, warning=FALSE}
plotDispEsts(dds)
```

# Run deseq analysis
```{r deseq analysis, message=FALSE, warning=FALSE}
dds <- DESeq(dds)
```
# Steps required to generate a results table for pairwise comparisons (Wald test)
By default DESeq2 uses the Wald test to identify genes that are differentially expressed between two groups of samples. Results can be extracted for a number of different comparisons.
This is done through the following steps:
  * A regression model fits to each gene (glm.nb),
  * Each gene model coefficient (LFC) is extimated using maximum likelihood,
  * The shrunken estimate of LFC is divided by its standard error, resulting in a z-statistic,
  * z-statistic is compared to a standard normal distribution to compute the p-values,
  * P values are adjusted for multiple testing using the procedure of Benjamini and Hochberg.

```{r pvalue, eval=TRUE, message=FALSE, warning=FALSE}
    # P-value distribution
    res <- results(dds)
    # print(mcols(res, use.names=TRUE))
    res.df <- res %>% data.frame() 
    print(ggplot(res.df) +
        geom_histogram(aes(res.df$pvalue, fill = "a"), colour = "grey20", alpha = 0.5, stat = "bin") +
        geom_histogram(aes(res.df$padj, fill = "b"), colour = "grey20", alpha = 0.5, stat = "bin") +
        scale_fill_manual(name = "group", values = c("a" = "steelblue", "b" = "grey20"),
                    labels = c("a" = "p-value", "b" = "padj")) +
        geom_vline(xintercept = 0.05, colour = "red")
    )
```

# Make a pairwise comparison (using contrast)
Contrasts can be given as a list of 2 character vectors:
the names of the fold changes for the level of ineterest, and the names of the fold changes for the base level.
```{r contrast, message=FALSE, warning=FALSE}
resultsNames(dds) # to see what names to use
contrast <- c("celltype", "JJ", "BM")
#contrast <- list(resultsNames(dds)[1], resultsNames(dds)[2])
```
If there is only two factor levels, There is no need to  specify contrasts, DESeq2 will choose the base factor level based on the alphabetical order of the levels.

```{r result, message=FALSE, warning=FALSE}
# which contrast are we interested in?
res <- results(dds, contrast = contrast, alpha = 0.05)
```

# Results
```{r view res, message=FALSE, warning=FALSE}
# What type of object is the results?
class(res)
# What is in the results?
res %>% data.frame() %>% head()
```
Columns of results dataframe:

  * baseMean: mean of normalized counts for all samples

  * log2FoldChange: log2 fold change

  * lfcSE: standard error

  * stat: Wald statistic

  * pvalue: Wald test p-value

  * padj: BH adjusted p-values

The padj column represents the p-value adjusted for multiple testing, and is the most important column of the results! The default method for multiple test correction in DESeq2 is an implementation of the Benjamini-Hochberg false discovery rate (FDR).
If a gene contains a sample with an extreme count outlier then the p-value and adjusted p-value will be set to NA.

# Plot of the mean normalized counts vs log10(p values)
```{r plot norm_count vs p values}
plot(res$baseMean+1, -log10(res$pvalue),
     log="x", xlab="mean of normalized counts",
     ylab=expression(-log[10](pvalue)),
     ylim=c(0,30),
     cex=.4, col=rgb(0,0,0,.3))

```

# Shrinkage method
To generate more accurate log2 foldchange (LFC) estimates, DESeq2 allows for the shrinkage of the LFC estimates toward zero when the information for a gene is low, which could include:
- Low counts
- High dispersion values
LFC shrinkage uses information from all genes to generate more accurate estimates. Specifically, the distribution of LFC estimates for all genes is used (as a prior) to shrink the LFC estimates of genes with little information or high dispersion toward more likely (lower) LFC estimates.
```{r shrink, message=FALSE, warning=FALSE}
# which coef to use?
resultsNames(dds)
res_shrink <- lfcShrink(dds, coef="celltype_JJ_vs_BM", type="apeglm")
```
To get the coef name check resultsNames(dds)

text
# MA plot
```{r MA plot, message=FALSE, warning=FALSE}
plotMA(res, ylim=c(-2,2))
plotMA(res_shrink, ylim=c(-2,2))
```
text
# summary
```{r summary, message=FALSE, warning=FALSE}
summary(res_shrink, alpha = 0.05)
cutoff <- 0.05
res_sig <- subset(res_shrink, padj<cutoff)
res_sig_sorted = res_sig[order(res_sig$padj), ]
head(res_sig_sorted)
```
# Visualisation
```{r visualisation, message=FALSE, warning=FALSE}
# plot a single gene
plotCounts(dds, gene = "ENSG00000164062", intgroup = "celltype")
# To see the data underneath the figure
d <- plotCounts(dds, gene = "ENSG00000164062", intgroup = "celltype", returnData=TRUE)
#d %>% View()
# can be used for ggplot
ggplot(d, aes(x = celltype, y = count, color = celltype)) +
    geom_point(position=position_jitter(w = 0.1,h = 0)) +
    geom_text_repel(aes(label = rownames(d))) +
    theme_bw() +
    ggtitle("ENSG00000164062") +
    theme(plot.title = element_text(hjust = 0.5))
```
Extract the normalized values of all the significant genes and plot a heatmap of their expression using `pheatmap()`.

```{r heatmap, message=FALSE, warning=FALSE}
normalized_counts <- counts(dds, normalized=T)[,c(10:12,4:6)]
norm_sig <- subset(normalized_counts, row.names(normalized_counts) %in% row.names(res_sig_sorted))
head(norm_sig[,1:6])
# pheatmap(norm_sig[,1:6],
#     cluster_rows = T,
#     show_rownames = F,
#     annotation = meta,
#     border_color = NA,
#     fontsize = 10,
#     scale = "row",
#     fontsize_row = 10,
#     height = 20)

```
A commonly used plot to have a global view of the expression is volcano plot; in which the log transformed adjusted p-values plotted on the y-axis and log2 fold change values on the x-axis.
```{r volcano plot, message=FALSE, warning=FALSE}


```
#Likelihood ratio test
DESeq2 also offers the Likelihood Ratio Test (LRT) as an alternative when evaluating expression change across more than two levels. Rather than evaluating whether a gene’s expression is up- or down-regulated in one class compared to another, it identifies genes which are changing in expression in any direction across the different factor levels. Therefore, there is no need for contrasts since we are not making a pair-wise comparison.
The LRT is comparing the 'full' model to the 'reduced' model to identify significant genes. The p-values are determined solely by the difference in deviance between the ‘full’ and the ‘reduced’ model formula (not the log2 fold changes). Essentially the LRT test is testing whether the term(s) removed in the ‘reduced’ model explains a significant amount of variation in the data
```{r lrt, message=FALSE, warning=FALSE}
# which model are we interested in as reduced?
dds_lrt <- DESeq(dds, test="LRT", reduced = ~celltype + condition)
res_lrt <- results(dds_lrt)
head(res_lrt)

```
Columns relevant to the LRT test:
* baseMean: mean of normalized counts for all samples
* stat: the difference in deviance between the reduced model and the full model
* pvalue: the stat value is compared to a chi-squared distribution to generate a pvalue
* padj: BH adjusted p-values
```{r detect lrt sig genes, message=FALSE, warning=FALSE}
# padj < 0.05
sig_res_lrt <- res_lrt %>%
               data.frame() %>%
               rownames_to_column(var="gene") %>%
               as_tibble() %>%
               filter(padj < 0.05)
head(sig_res_lrt)
# Get sig gene lists
sig_lrt_genes <- sig_res_lrt %>%
                pull(gene)

length(sig_lrt_genes)

# Compare to numbers we had from Wald test
# ???

```


We now have an idea on how we can extract pair-wise comparisons from a multi-factor DESeq2 analysis,
and we got a primer on comparisons beyond pair-wise comparisons. What now ?
Let's try to extract something biologically meaningful from the data.

Poll1:
Is there a difference between specifying ~celltype*condition and ~celltype + condition + celltype:condition ?

To go on, we have to remember that this is in essence a drug repurposing study.

A couple of other relevant notes:

 - BM and JJ are two cell lines generated multiple myeloma patients.
 - (alternative) splicing is affected in these patients.
 - TG003 is a drug commonly used in this disease (clk1 kinase inhibitor)
 - Amiloride is an old drug (diuretic) that is hypothesized to be a good candidate for repurposing in multiple myeloma.

Let's start by assessing the difference between amiloride treated cells and TG treated cells.

Remember our coefficients:
```{r coefficients dds, message=FALSE, warning=FALSE}
resultsNames(dds)
```

Extract TG vs AMIL:

```{r message=FALSE, warning=FALSE}
TGvAMIL <- results(dds, contrast = c('condition', 'TG', 'AMIL'), alpha = 0.05)
head( data.frame(TGvAMIL) )

#or

TGvAMIL <- results(dds, contrast = c(0,0,0,1,0,0), alpha=0.05)
head( data.frame(TGvAMIL) )
```

Cave!
If we want to use shrinking, be careful with the apegml method as lfcShrink method doesn't support all forms of contrasts.
ashr-method is a bit more versatile.


```{r message=FALSE, warning=FALSE}
#TGvAMIL_shrunk <- lfcShrink(dds, contrast=c(0,0,0,1,0,0), type="apeglm") # This WONT work.
TGvAMIL_shrunk <- lfcShrink(dds, coef=c('condition_TG_vs_AMIL'), type="apeglm") # This will work.
```

We now have TG vs AMIL, but are these results for the BM or the JJ cells ?

Poll2:
BM
JJ

We have two options now. Or we re-run deseq with releveled factors, or we dive a bit in the contrast setting of results.
For cellType JJ, the difference between condition TG and AMIL is:
The effect of AMIL-TG + interaction TG-JJ:

```{r message=FALSE, warning=FALSE}
TGvAMIL_JJ <- results(dds, contrast = c(0,0,0,1,0,1), alpha=0.05)
# Recall the contrasts:
resultsNames(dds)
```

Let's glance at the results now.

```{r message=FALSE, warning=FALSE}
cleanDF <- function(RESobj){
  RESdf <- data.frame(RESobj) %>%
    filter(baseMean > 0) %>%
    drop_na() %>%
    arrange(padj)
  return(RESdf)
}

TGvAMIL_JJ_cleaned <- cleanDF(TGvAMIL_JJ)
TGvAMIL_BM_cleaned <- cleanDF(TGvAMIL)

# Plot Zscores for top20 hits.
pheatmap(
  counts(dds, normalized=TRUE)[head( rownames(TGvAMIL_JJ_cleaned) , n=20), c("JJ_AMIL_1",
                                                                             "JJ_AMIL_2",
                                                                             "JJ_AMIL_3",
                                                                             "JJ_TG_1",
                                                                             "JJ_TG_2",
                                                                             "JJ_TG_3")],
  scale = 'row',
  main='TG v AMIL - JJ'
  )

pheatmap(
  counts(dds, normalized=TRUE)[head( rownames(TGvAMIL_BM_cleaned) , n=20), c("BM_AMIL_1",
                                                                             "BM_AMIL_2",
                                                                             "BM_AMIL_3",
                                                                             "BM_TG_1",
                                                                             "BM_TG_2",
                                                                             "BM_TG_3")],
  scale = 'row',
  main='TG v AMIL - JJ'
  )
```

To look at the similarity:

```{r message = FALSE, warning = FALSE}
upsetList <- list(
  "BM - Up" = rownames( TGvAMIL_BM_cleaned[ (TGvAMIL_BM_cleaned$log2FoldChange > 2) & (TGvAMIL_BM_cleaned$padj < 0.05),] ),
  "BM - Down" = rownames( TGvAMIL_BM_cleaned[ (TGvAMIL_BM_cleaned$log2FoldChange < -2) & (TGvAMIL_BM_cleaned$padj < 0.05),] ),
  "JJ - Up" = rownames( TGvAMIL_JJ_cleaned[ (TGvAMIL_JJ_cleaned$log2FoldChange > 2) & (TGvAMIL_JJ_cleaned$padj < 0.05),] ),
  "JJ - Down" = rownames( TGvAMIL_JJ_cleaned[ (TGvAMIL_JJ_cleaned$log2FoldChange < -2) & (TGvAMIL_JJ_cleaned$padj < 0.05),] )
  )

upset(fromList(upsetList), order.by = "freq")
```


Finally, look at two specific geneSets.
 - genes involved in splicing
 - genes involved in apoptosis
