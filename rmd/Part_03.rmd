---
title: "deseq2"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 2
    toc_float: true
    df_print: paged
---
# Goals:
* Different steps of a differential gene expression analysis
  * multi-factor design
  * Normalisation: Estimating size factors (has been explained before)
  * Checking for the dispertion (has been explained before)
  * Building up contrasts
  * Make a results table
  * Summarize and extract a list of significant differentially expressed genes
  * Visualize the results
  * LRT vs. Wald test
  * Biological interpretation

```{r add libraries, message=FALSE, warning=FALSE, paged.print=FALSE}
# add libraries
.libPaths("/data/processing3/RdeseqCourse/RdeseqEnv/R-4.0.3_Rcourse/lib64/R/library")
library("DESeq2")
library("dplyr")
library("tibble")
library("ggplot2")
library("ggrepel")
library("pheatmap")
library("EnsDb.Hsapiens.v75")
library("UpSetR")
library("tidyr")
library("ashr")
```

```{r Get the data directroy, message=FALSE, warning=FALSE}
# Get the data directory
data_dir <- "/data/manke/processing/RdeseqData/myeloma/"

# Read count matrix
countdata <- read.table(paste0(data_dir, "corrected_counts.tsv", sep=''),
                        header=TRUE, check.names = TRUE)
#head(countdata)

# Read samplesheet , detects conditions, generate the formula
sampleInfo <- read.table(paste0(data_dir, "corrected_meta.tsv", sep=''),
                          header=TRUE, check.names = TRUE, stringsAsFactor = F)
sampleInfo$celltype <- as.factor(sampleInfo$celltype)
sampleInfo$condition <- as.factor(sampleInfo$condition)
print(sampleInfo)
```

# Building a deseq data set with a multi-factor design:
## factors and designs:
Multi-factor design with increasing complexity are nicely explained in these [slides](https://docs.google.com/presentation/d/1B9zW1_F-kBqQEu4xqxIJrudYP5DecytYMRR6bY4H6aM/edit?usp=sharing)

### The simplest case:
 * one factor with two levels

|samples |condition<factor> |
|:-------|:-----|
|sample1 |cond1 |
|sample2 |cond1 |
|sample3 |cond2 |
|sample4 |cond2 |

Design: 

      ~1+condition (or ~condition)
      = beta0 + beta1 * cond2

This results in the coefficient for the intercept and coefficient for the effect of “cond2” (i.e. differences between cond2 vs. cond1).

    [1] "Intercept" (beta0)             "condition_cond2_vs_cond1" (beta1)


This can be shown by dummy variables:

|samples | (Intercept) | condtioncond2 |
|:-------|:----|:----|
|sample1 |1 | 0 |
|sample2 |1 | 0 |
|sample3 |1 | 1 |
|sample4 |1 | 1 |

null hypothesis:

    beta1 = 0

### A complex case:
 * One factor with more than two levels

|samples |condition<factor> |
|:-------|:-----|
|sample1 |cond1 |
|sample2 |cond1 |
|sample3 |cond2 |
|sample4 |cond2 |
|sample5 |cond3 |
|sample6 |cond3 |

      ~1+condition
      = beta0 + beta1 * cond2 + beta2 * cond3
      beta0 = Intercept
      beta1 = condition_cond2_vs_cond1
      beta2 = condition_cond3_vs_cond1
Coefficients:

      [1] "Intercept"              "condition_cond2_vs_cond1" "condition_cond3_vs_cond1" 

Model matrix:

|samples | (Intercept) | condtioncond2 | condtioncond3 |
|:-------|:----|:----|:----|
|sample1 |1 | 0 | 0 |
|sample2 |1 | 0 | 0 |
|sample3 |1 | 1 | 0 |
|sample4 |1 | 1 | 0 |
|sample5 |1 | 0 | 1 |
|sample6 |1 | 0 | 1 |

Null hypothesis:

    cond2 vs cond1
    beta1 = 0

    cond3 vs cond1
    beta2 = 0

    cond2 vs cond3
    beta1 - beta2 = 0

### More complex case:
  * Two factors, with interaction
  
|samples |condition<factor> | treatment<factor> |
|:-------|:-----|:-----|
|sample1 |cond1 |treat1|
|sample2 |cond1 |treat1|
|sample3 |cond1 |treat2|
|sample4 |cond1 |treat2|
|sample5 |cond2 |treat1|
|sample6 |cond2 |treat1|
|sample7 |cond2 |treat2|
|sample8 |cond2 |treat2|

The formula for the model includes all sources of variation in the data. Thus, it should contain the condition, treatment and the difference as the effect of condtion on the treatment (condtion:treatment)

Design:

    ~1 + condition + treatment + condition:treatment
    = beta0 + beta1 * cond2 + beta2 * treatment2 + beta3 * cond2.treat2
      beta0 = Intercept
      beta1 = condition_cond2_vs_cond1
      beta2 = treatment_treat2_vs_treat1
      beta3 = conditioncond2.treatmenttreat2

Null hypothesis:

    cond2 vs cond1 (treat1) 
    beta1 = 0

    cond2 vs cond1 (treat2)
    beta1 + beta3 = 0

    treat2 vs treat1 (cond1):
    beta2 = 0

    treat2 vs treat1 (cond2):
    beta2 + beta3 = 0

    Interaction:
    beta3 = 0

```{r build the matrix, message=FALSE, warning=FALSE}
design <- as.formula(~celltype + condition + celltype:condition)
dds <- DESeq2::DESeqDataSetFromMatrix(countData = countdata, colData = sampleInfo, design = design)
```

# Estimate size factors
DESeq2 automatically estimates the size factors when performing the differential expression analysis. However, if `estimateSizeFactors()` is called, then DESeq2 will use these values.

To normalize the count data, DESeq2 calculates size factors for each sample using the "median of ratios" method.
```{r estimate size factors, message=FALSE, warning=FALSE}
dds <- estimateSizeFactors(dds)
sizeFactors(dds)
```

# Find the relation between the size factors and the values of the columns:
```{r colsums, message=FALSE, warning=FALSE}
colSums(counts(dds))
```
Larger size factors correspond to the samples with higher sequencing depth. To generate the normalized counts we need to divide the counts by the size factors. This accounts for the differences in sequencing depth between samples.

# compare the raw sum with the normalised ones:
```{r norm colsums, message=FALSE, warning=FALSE}
colSums(counts(dds, normalized=T))
```

# Importance of dispersion during differential expression analysis
DESeq2 uses a measure of variation called dispersion, which accounts for a gene’s variance and mean expression level. Dispersion is calculated by `Var = μ + α*μ^2`, where `α` = dispersion, `Var` = variance, and `μ` = mean
# Estimate dispersion
```{r estimate dispersions, message=FALSE, warning=FALSE}
# To generate more accurate estimates of variation based on the mean expression level of the gene using a method called ‘shrinkage’. DESeq2 assumes that genes with similar expression levels should have similar dispersion. (??)
dds <- estimateDispersions(dds)
```
# Visualise dispersion
```{r Visualise dispersions, message=FALSE, warning=FALSE}
plotDispEsts(dds)
```

# Run deseq analysis
```{r deseq analysis, message=FALSE, warning=FALSE}
dds <- DESeq(dds)
```
# Steps required to generate a results table for pairwise comparisons (Wald test)
By default DESeq2 uses the Wald test to identify genes that are differentially expressed between two groups of samples. Results can be extracted for a number of different comparisons.
This is done through the following steps:
  * A regression model fits to each gene (glm.nb),
  * Each gene model coefficient (LFC) is extimated using maximum likelihood,
  * The shrunken estimate of LFC is divided by its standard error, resulting in a z-statistic,
  * z-statistic is compared to a standard normal distribution to compute the p-values,
  * P values are adjusted for multiple testing using the procedure of Benjamini and Hochberg.

```{r pvalue, eval=TRUE, message=FALSE, warning=FALSE}
    # P-value distribution
    res <- results(dds)
    # print(mcols(res, use.names=TRUE))
    res.df <- res %>% data.frame() 
    print(ggplot(res.df) +
        geom_histogram(aes(res.df$pvalue, fill = "a"), colour = "grey20", alpha = 0.5, stat = "bin") +
        geom_histogram(aes(res.df$padj, fill = "b"), colour = "grey20", alpha = 0.5, stat = "bin") +
        scale_fill_manual(name = "group", values = c("a" = "steelblue", "b" = "grey20"),
                    labels = c("a" = "p-value", "b" = "padj")) +
        geom_vline(xintercept = 0.05, colour = "red")
    )
```

# Make a pairwise comparison (using contrast)
Contrasts can be given as a list of 2 character vectors:
the names of the fold changes for the level of ineterest, and the names of the fold changes for the base level.
```{r contrast, message=FALSE, warning=FALSE}
resultsNames(dds) # to see what names to use
contrast <- c("celltype", "JJ", "BM")
#contrast <- list(resultsNames(dds)[1], resultsNames(dds)[2])
```
If there is only two factor levels, There is no need to  specify contrasts, DESeq2 will choose the base factor level based on the alphabetical order of the levels.

```{r result, message=FALSE, warning=FALSE}
# which contrast are we interested in?
res <- results(dds, contrast = contrast, alpha = 0.05)
```

# Results
```{r view res, message=FALSE, warning=FALSE}
# What type of object is the results?
class(res)
# What is in the results?
res %>% data.frame() %>% head()
```
Columns of results dataframe:

  * baseMean: mean of normalized counts for all samples

  * log2FoldChange: log2 fold change

  * lfcSE: standard error

  * stat: Wald statistic

  * pvalue: Wald test p-value

  * padj: BH adjusted p-values

The padj column represents the p-value adjusted for multiple testing, and is the most important column of the results! The default method for multiple test correction in DESeq2 is an implementation of the Benjamini-Hochberg false discovery rate (FDR).
If a gene contains a sample with an extreme count outlier then the p-value and adjusted p-value will be set to NA.

# Plot of the mean normalized counts vs log10(p values)
```{r plot norm_count vs p values}
plot(res$baseMean+1, -log10(res$pvalue),
     log="x", xlab="mean of normalized counts",
     ylab=expression(-log[10](pvalue)),
     ylim=c(0,30),
     cex=.4, col=rgb(0,0,0,.3))

```

# Shrinkage method
To generate more accurate log2 foldchange (LFC) estimates, DESeq2 allows for the shrinkage of the LFC estimates toward zero when the information for a gene is low, which could include:
- Low counts
- High dispersion values
LFC shrinkage uses information from all genes to generate more accurate estimates. Specifically, the distribution of LFC estimates for all genes is used (as a prior) to shrink the LFC estimates of genes with little information or high dispersion toward more likely (lower) LFC estimates.
```{r shrink, message=FALSE, warning=FALSE}
# which coef to use?
resultsNames(dds)
res_shrink <- lfcShrink(dds, coef="celltype_JJ_vs_BM", type="apeglm")
```
To get the coef name check resultsNames(dds)

text
# MA plot
```{r MA plot, message=FALSE, warning=FALSE}
plotMA(res, ylim=c(-2,2))
plotMA(res_shrink, ylim=c(-2,2))
```
text
# summary
```{r summary, message=FALSE, warning=FALSE}
summary(res_shrink, alpha = 0.05)
cutoff <- 0.05
res_sig <- subset(res_shrink, padj<cutoff)
res_sig_sorted = res_sig[order(res_sig$padj), ]
head(res_sig_sorted)
```
# Visualisation
```{r visualisation, message=FALSE, warning=FALSE}
# plot a single gene
plotCounts(dds, gene = "ENSG00000164062", intgroup = "celltype")
# To see the data underneath the figure
d <- plotCounts(dds, gene = "ENSG00000164062", intgroup = "celltype", returnData=TRUE)
#d %>% View()
# can be used for ggplot
ggplot(d, aes(x = celltype, y = count, color = celltype)) +
    geom_point(position=position_jitter(w = 0.1,h = 0)) +
    geom_text_repel(aes(label = rownames(d))) +
    theme_bw() +
    ggtitle("ENSG00000164062") +
    theme(plot.title = element_text(hjust = 0.5))
```
Extract the normalized values of all the significant genes and plot a heatmap of their expression using `pheatmap()`.

```{r heatmap, message=FALSE, warning=FALSE}
normalized_counts <- counts(dds, normalized=T)[,c(10:12,4:6)]
norm_sig <- subset(normalized_counts, row.names(normalized_counts) %in% row.names(res_sig_sorted))
head(norm_sig[,1:6])
# pheatmap(norm_sig[,1:6],
#     cluster_rows = T,
#     show_rownames = F,
#     annotation = meta,
#     border_color = NA,
#     fontsize = 10,
#     scale = "row",
#     fontsize_row = 10,
#     height = 20)

```
A commonly used plot to have a global view of the expression is volcano plot; in which the log transformed adjusted p-values plotted on the y-axis and log2 fold change values on the x-axis.
```{r volcano plot, message=FALSE, warning=FALSE}


```
#Likelihood ratio test
DESeq2 also offers the Likelihood Ratio Test (LRT) as an alternative when evaluating expression change across more than two levels. Rather than evaluating whether a gene’s expression is up- or down-regulated in one class compared to another, it identifies genes which are changing in expression in any direction across the different factor levels. Therefore, there is no need for contrasts since we are not making a pair-wise comparison.
The LRT is comparing the 'full' model to the 'reduced' model to identify significant genes. The p-values are determined solely by the difference in deviance between the ‘full’ and the ‘reduced’ model formula (not the log2 fold changes). Essentially the LRT test is testing whether the term(s) removed in the ‘reduced’ model explains a significant amount of variation in the data
```{r lrt, message=FALSE, warning=FALSE}
# which model are we interested in as reduced?
dds_lrt <- DESeq(dds, test="LRT", reduced = ~celltype + condition)
res_lrt <- results(dds_lrt)
head(res_lrt)

```
Columns relevant to the LRT test:
* baseMean: mean of normalized counts for all samples
* stat: the difference in deviance between the reduced model and the full model
* pvalue: the stat value is compared to a chi-squared distribution to generate a pvalue
* padj: BH adjusted p-values
```{r detect lrt sig genes, message=FALSE, warning=FALSE}
# padj < 0.05
sig_res_lrt <- res_lrt %>%
               data.frame() %>%
               rownames_to_column(var="gene") %>%
               as_tibble() %>%
               dplyr::filter(padj < 0.05)
head(sig_res_lrt)
# Get sig gene lists
sig_lrt_genes <- sig_res_lrt %>%
                pull(gene)

length(sig_lrt_genes)

# Compare to numbers we had from Wald test
# ???

```


# Biological interpretation
## Introduction

We now have an idea on how we can extract pair-wise comparisons from a multi-factor DESeq2 analysis,
and we got a primer on comparisons beyond pair-wise comparisons. What now ?
Let's try to extract something biologically meaningful from the data.

Remember our design was specified as follows:

```{r designPrinter, message=FALSE, warning=FALSE}
print(design)
```

and our factors:

```{r design, message=FALSE, warning=FALSE}
print(sampleInfo$celltype)
print(sampleInfo$condition)
```


> **Poll1**:
> Is there a difference between specifying ~celltype*condition and ~celltype + condition + celltype:condition ?


To move on, remember that this is in essence a drug repurposing study.

A couple of other relevant notes:

 - BM and JJ are two cell lines generated from multiple myeloma patients.
 - (alternative) splicing is affected in this cancer.
 - TG003 is a drug commonly used in this disease (clk1 kinase inhibitor)
 - Amiloride is an old drug (diuretic) that is hypothesized to be a good candidate for repurposing in multiple myeloma.

## amiloride vs TG

Let's start by assessing the difference between amiloride treated cells and TG treated cells.

Remember our coefficients:
```{r coefficients dds, message=FALSE, warning=FALSE}
resultsNames(dds)
```

Extract TG vs AMIL:

```{r extract TG vs AMIL, message=FALSE, warning=FALSE}
TGvAMIL <- lfcShrink(dds, contrast = c('condition', 'TG', 'AMIL'), type="ashr")
head( data.frame(TGvAMIL) )

#or

TGvAMIL <- lfcShrink(dds, contrast = c(0,0,0,1,0,0), type="ashr")
head( data.frame(TGvAMIL) )
```

Cave!
If we want to use shrinking, be careful with the apegml method as lfcShrink method doesn't support all forms of contrasts.
ashr-method is a bit more versatile.

> **Poll 3.2**:
> We now have TG vs AMIL results, but are these under the BM or JJ condition ??

> **Poll3.3**:
> Given our contrast c('condition', 'TG', 'AMIL'), what would a (significant) positive foldchange correspond to ?

```{r return celltype, message=FALSE, warning=FALSE}
print(sampleInfo$celltype)
```

We have two options now. Or we re-run deseq with releveled factors, or we dive a bit in the contrast setting of results. Please note if you insist on using apeglm or normal method for shrinking, you have no other choice then to relevel !

For cellType JJ, the difference between condition TG and AMIL is:
The effect of AMIL-TG + interaction TG-JJ:

```{r message=FALSE, warning=FALSE}
TGvAMIL_JJ <- lfcShrink(dds, contrast = c(0,0,0,1,0,1), type="ashr")
# Recall the contrasts:
resultsNames(dds)
```

## Clean & Annotate

One more 'issue' we need to tackle: we only have transcript IDs, not actual gene names. There are a couple of packages that take care of the conversion, and one of the most used is [biomaRt](https://bioconductor.org/packages/release/bioc/html/biomaRt.html). For this course we won't rely on it, since it uses an API (and we'll probably get blocked). An alternative is the [org.Hs.eg.db](https://bioconductor.org/packages/release/data/annotation/html/org.Hs.eg.db.html) package, which keeps all needed files locally (note the Hs stands for Homo Sapiens, and thus can only be used for this matter. As you probably guessed, for most model organisms there is a package like this (mm, sp, ...) ). Since the data is processed with GRCh37, we will use the following database: "EnsDb.Hsapiens.v75". How to utilize these libraries differs from library to library, but is usually pretty well documented.

In our case we can use:


> ensembldb::select(EnsDb.Hsapiens.v79, keys= ensemble, keytype = "GENEID", columns = c("SYMBOL","GENEID"))

Cave! Some function between ensembldb (part of EnsDb.Hsapiens.v79) and dplyr overlap. Explicitely state the library when calling them to avoid errors.

> **Task**:
> Treat both result objects as such that we have:
> A dataframe
> genes with baseMean 0 are filtered out.
> rows with 'NA' are filtered out.
> Optional: create an additional column in the dataframe with the gene symbols
> Optional: Wrap the operations in a function


```{r parseResults, message=FALSE, warning=FALSE}
cleanDF <- function(RESobj){
  RESdf <- data.frame(RESobj) %>%
    dplyr::filter(baseMean > 0) %>%
    drop_na() %>%
    arrange(padj)
  RESdf$gene_symbol <- ensembldb::select(EnsDb.Hsapiens.v75, keys = rownames(RESdf),
                                         keytype = "GENEID", columns = c("SYMBOL", "GENEID"))$SYMBOL
  return(RESdf)
}

TGvAMIL_JJ_cleaned <- cleanDF(TGvAMIL_JJ)
TGvAMIL_BM_cleaned <- cleanDF(TGvAMIL)

# Plot Zscores for top20 hits.
pheatmap(
  counts(dds, normalized=TRUE)[head( rownames(TGvAMIL_JJ_cleaned) , n=20), c("JJ_AMIL_1",
                                                                             "JJ_AMIL_2",
                                                                             "JJ_AMIL_3",
                                                                             "JJ_TG_1",
                                                                             "JJ_TG_2",
                                                                             "JJ_TG_3")],
  scale = 'row',
  main='TG v AMIL - JJ',
  labels_row = paste0(head(TGvAMIL_JJ_cleaned$gene_symbol, n=20), ' ', head(rownames(TGvAMIL_JJ_cleaned), n=20 ))
)

pheatmap(
  counts(dds, normalized=TRUE)[head( rownames(TGvAMIL_BM_cleaned) , n=20), c("BM_AMIL_1",
                                                                             "BM_AMIL_2",
                                                                             "BM_AMIL_3",
                                                                             "BM_TG_1",
                                                                             "BM_TG_2",
                                                                             "BM_TG_3")],
  scale = 'row',
  main='TG v AMIL - JJ',
  labels_row = paste0(head(TGvAMIL_BM_cleaned$gene_symbol, n=20), ' ', head(rownames(TGvAMIL_BM_cleaned), n=20 ))
  )
```

To look at the similarity:

```{r UpsetPlot, message = FALSE, warning = FALSE}
upsetList <- list(
  "BM - Up" = rownames( TGvAMIL_BM_cleaned[ (TGvAMIL_BM_cleaned$log2FoldChange > 2) & (TGvAMIL_BM_cleaned$padj < 0.05),] ),
  "BM - Down" = rownames( TGvAMIL_BM_cleaned[ (TGvAMIL_BM_cleaned$log2FoldChange < -2) & (TGvAMIL_BM_cleaned$padj < 0.05),] ),
  "JJ - Up" = rownames( TGvAMIL_JJ_cleaned[ (TGvAMIL_JJ_cleaned$log2FoldChange > 2) & (TGvAMIL_JJ_cleaned$padj < 0.05),] ),
  "JJ - Down" = rownames( TGvAMIL_JJ_cleaned[ (TGvAMIL_JJ_cleaned$log2FoldChange < -2) & (TGvAMIL_JJ_cleaned$padj < 0.05),] )
  )

upset(fromList(upsetList), order.by = "freq")
```

## Apoptosis & Spliceosome

Finally, look at two specific geneSets.
 - genes involved in splicing
 - genes involved in apoptosis
 
```{r Pathways, message = FALSE, warning = FALSE}
data_dir <- "/data/manke/processing/RdeseqData/genesets/"
kegg_apoptosis <-  read.table(paste0(data_dir, "KEGG_apoptosis.txt", sep=''),
                          header=FALSE, stringsAsFactor = F)
kegg_apoptosis <- kegg_apoptosis$V1

kegg_spliceosome <-  read.table(paste0(data_dir, "KEGG_spliceosome.txt", sep=''),
                          header=FALSE, stringsAsFactor = F)
kegg_spliceosome <- kegg_spliceosome$V1

retIDsfromSymbolList <- function(df, symbols){
  return(rownames(df[(df$gene_symbol %in% symbols) & (df$padj < 0.05),]) )
}
# spliceosome

pheatmap(
  counts(dds, normalized=TRUE)[retIDsfromSymbolList(TGvAMIL_BM_cleaned,
                                                    kegg_spliceosome), c("BM_CTRL_2",
                                                                         "BM_CTRL_3",
                                                                         "BM_AMIL_1",
                                                                         "BM_AMIL_2",
                                                                         "BM_AMIL_3",
                                                                         "BM_TG_1",
                                                                         "BM_TG_2",
                                                                         "BM_TG_3")],
  scale = 'row',
  main='TG v AMIL - JJ : spliceosome',
  fontsize=5,
  labels_row = TGvAMIL_BM_cleaned[(TGvAMIL_BM_cleaned$gene_symbol %in% kegg_spliceosome) & (TGvAMIL_BM_cleaned$padj < 0.05),]$gene_symbol
)

# Apoptosis

pheatmap(
  counts(dds, normalized=TRUE)[retIDsfromSymbolList(TGvAMIL_BM_cleaned,
                                                    kegg_apoptosis), c("BM_CTRL_2",
                                                                         "BM_CTRL_3",
                                                                         "BM_AMIL_1",
                                                                         "BM_AMIL_2",
                                                                         "BM_AMIL_3",
                                                                         "BM_TG_1",
                                                                         "BM_TG_2",
                                                                         "BM_TG_3")],
  scale = 'row',
  main='TG v AMIL - JJ : apoptosis',
  fontsize=5,
  labels_row = TGvAMIL_BM_cleaned[(TGvAMIL_BM_cleaned$gene_symbol %in% kegg_apoptosis) & (TGvAMIL_BM_cleaned$padj < 0.05),]$gene_symbol
)
```

## LRT

Finally, let's look at the treatment factor using LRT. For this we'll use ~celltype as the reduced model.

```{r lrt-condition, message=FALSE, warning=FALSE}
# which model are we interested in as reduced?
dds_lrt <- DESeq(dds, test="LRT", reduced = ~celltype)
res_lrt <- results(dds_lrt)
```

Now let's clean the dataframe, write out the results in a tsv file, and redo our heatmap exercise for the
pathways.

```{r parse lrt, message=FALSE, warning=FALSE}
res_lrt_clean <- cleanDF(res_lrt)
res_lrt_clean
# Write out results in a tsv file.

write.table(res_lrt_clean, file="~/lrtResults.tsv", quote = FALSE, sep = "\t")

# spliceosome
pheatmap(
  counts(dds, normalized=TRUE)[retIDsfromSymbolList(res_lrt_clean,
                                                    kegg_spliceosome), c("BM_CTRL_2",
                                                                         "BM_CTRL_3",
                                                                         "BM_AMIL_1",
                                                                         "BM_AMIL_2",
                                                                         "BM_AMIL_3",
                                                                         "BM_TG_1",
                                                                         "BM_TG_2",
                                                                         "BM_TG_3")],
  scale = 'row',
  main='LRT : spliceosome',
  fontsize=5,
  labels_row = res_lrt_clean[(res_lrt_clean$gene_symbol %in% kegg_spliceosome) & (res_lrt_clean$padj < 0.05),]$gene_symbol
)

# Apoptosis
pheatmap(
  counts(dds, normalized=TRUE)[retIDsfromSymbolList(res_lrt_clean,
                                                    kegg_apoptosis), c("BM_CTRL_2",
                                                                         "BM_CTRL_3",
                                                                         "BM_AMIL_1",
                                                                         "BM_AMIL_2",
                                                                         "BM_AMIL_3",
                                                                         "BM_TG_1",
                                                                         "BM_TG_2",
                                                                         "BM_TG_3")],
  scale = 'row',
  main='LRT : apoptosis',
  fontsize=5,
  labels_row = TGvAMIL_BM_cleaned[(res_lrt_clean$gene_symbol %in% kegg_apoptosis) & (res_lrt_clean$padj < 0.05),]$gene_symbol
)

```

