---
title: "deseq2"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 2
    toc_float: true
    df_print: paged
---
# Goals:
* Different steps of a differential gene expression analysis
  * multi-factor design
  * Normalisation: Estimating size factors
  * Checking for the dispertion
  * Building up contrasts
  * Make a results table
  * Summarize and extract a list of significant differentially expressed genes
  * Visualize the results
  * LRT vs. Wald test

# add libraries
```{r add libraries, message=FALSE, warning=FALSE, paged.print=FALSE}
.libPaths("/data/manke/processing/RdeseqEnv/R-4.0.3_Rcourse/lib64/R/library") 
library("DESeq2")
library("dplyr")
library("tibble")
library("ggplot2")
library("ggrepel")
library("pheatmap")
library("org.Hs.eg.db")
library("UpSetR")
library("tidyr")
```
# Get the data directroy
```{r Get the data directroy, message=FALSE, warning=FALSE}
setwd("/data/processing1/leily/r_course/Rdeseq2/")
data_dir <- paste(getwd(), "data", "myeloma", sep = .Platform$file.sep)
#print(data_dir)

# Read count matrix
countdata <- read.table(paste(data_dir,"myeloma_counts.tsv", sep = "/"), header=TRUE, check.names = TRUE)
#head(countdata)

# Read samplesheet , detects conditions, generate the formula
sampleInfo <- read.table(paste(data_dir,"myeloma_meta.tsv", sep = "/"), header=TRUE, check.names = TRUE, stringsAsFactor = F)
sampleInfo$celltype <- as.factor(sampleInfo$celltype)
sampleInfo$condition <- as.factor(sampleInfo$condition)
head(sampleInfo)
```

# Building a deseq data set with a multi-factor design:
The formula for the model includes all sources of variation in the data:
celltype, condition and the difference as the effect of celltype on condition (celltype:condition)

```{r build the matrix, message=FALSE, warning=FALSE}
design <- ~celltype + condition + celltype:condition
dds <- DESeq2::DESeqDataSetFromMatrix(countData = countdata, colData = sampleInfo, design = design)
```

# Estimate size factors
DESeq2 automatically estimates the size factors when performing the differential expression analysis. However, if `estimateSizeFactors()` is called, then DESeq2 will use these values.

To normalize the count data, DESeq2 calculates size factors for each sample using the "median of ratios" method.
```{r estimate size factors, message=FALSE, warning=FALSE}
dds <- estimateSizeFactors(dds)
sizeFactors(dds)
```

# Find the relation between the size factors and the values of the columns:
```{r colsums, message=FALSE, warning=FALSE}
colSums(counts(dds))
```
Larger size factors correspond to the samples with higher sequencing depth. To generate the normalized counts we need to divide the counts by the size factors. This accounts for the differences in sequencing depth between samples.

# compare the raw sum with the normalised ones:
```{r norm colsums, message=FALSE, warning=FALSE}
colSums(counts(dds, normalized=T))
```

# Importance of dispersion during differential expression analysis
DESeq2 uses a measure of variation called dispersion, which accounts for a gene’s variance and mean expression level. Dispersion is calculated by `Var = μ + α*μ^2`, where `α` = dispersion, `Var` = variance, and `μ` = mean
# Estimate dispersion
```{r estimate dispersions, message=FALSE, warning=FALSE}
# To generate more accurate estimates of variation based on the mean expression level of the gene using a method called ‘shrinkage’. DESeq2 assumes that genes with similar expression levels should have similar dispersion. (??)
dds <- estimateDispersions(dds)
```
# Visualise dispersion
```{r Visualise dispersions, message=FALSE, warning=FALSE}
plotDispEsts(dds)
```

# Run deseq analysis
```{r deseq analysis, message=FALSE, warning=FALSE}
dds <- DESeq(dds)
```
# Steps required to generate a results table for pairwise comparisons (Wald test)
By default DESeq2 uses the Wald test to identify genes that are differentially expressed between two groups of samples. Results can be extracted for a number of different comparisons.

# Make a pairwise comparison (using contrast)
Contrasts can be given as a list of 2 character vectors:
the names of the fold changes for the level of ineterest, and the names of the fold changes for the base level.
```{r contrast, message=FALSE, warning=FALSE}
resultsNames(dds) # to see what names to use
# contrast_oe <- c("celltype", "JJ", "BM")
contrast <- list(resultsNames(dds)[1], resultsNames(dds)[2])
```
If there is only two factor levels, There is no need to  specify contrasts, DESeq2 will choose the base factor level based on the alphabetical order of the levels.

```{r result, message=FALSE, warning=FALSE}
# which contrast are we interested in?
res <- results(dds, contrast = contrast, alpha = 0.05)
```

# Results
```{r view res, message=FALSE, warning=FALSE}
# What type of object is the results?
class(res)
# What is in the results?
res %>% data.frame() %>% head()
```
Columns of results dataframe:

  * baseMean: mean of normalized counts for all samples

  * log2FoldChange: log2 fold change

  * lfcSE: standard error

  * stat: Wald statistic

  * pvalue: Wald test p-value

  * padj: BH adjusted p-values

The padj column represents the p-value adjusted for multiple testing, and is the most important column of the results! The default method for multiple test correction in DESeq2 is an implementation of the Benjamini-Hochberg false discovery rate (FDR).
If a gene contains a sample with an extreme count outlier then the p-value and adjusted p-value will be set to NA.

# Plot of the mean normalized counts vs log10(p values)
```{r plot norm_count vs p values}
plot(res$baseMean+1, -log10(res$pvalue),
     log="x", xlab="mean of normalized counts",
     ylab=expression(-log[10](pvalue)),
     ylim=c(0,30),
     cex=.4, col=rgb(0,0,0,.3))

```

# Shrinkage method
To generate more accurate log2 foldchange (LFC) estimates, DESeq2 allows for the shrinkage of the LFC estimates toward zero when the information for a gene is low, which could include:
- Low counts
- High dispersion values
LFC shrinkage uses information from all genes to generate more accurate estimates. Specifically, the distribution of LFC estimates for all genes is used (as a prior) to shrink the LFC estimates of genes with little information or high dispersion toward more likely (lower) LFC estimates.
```{r shrink, message=FALSE, warning=FALSE}
# which coef to use?
resultsNames(dds)
res_shrink <- lfcShrink(dds, coef="celltype_JJ_vs_BM", type="apeglm")
```
To get the coef name check resultsNames(dds)

text
# MA plot
```{r MA plot, message=FALSE, warning=FALSE}
plotMA(res, ylim=c(-2,2))
plotMA(res_shrink, ylim=c(-2,2))
```
text
# summary
```{r summary, message=FALSE, warning=FALSE}
summary(res_shrink, alpha = 0.05)
cutoff <- 0.05
res_sig <- subset(res_shrink, padj<cutoff)
res_sig_sorted = res_sig[order(res_sig$padj), ]
head(res_sig_sorted)
```
# Visualisation
```{r visualisation, message=FALSE, warning=FALSE}
# plot a single gene
plotCounts(dds, gene = "ENSG00000164062", intgroup = "celltype")
# To see the data underneath the figure
d <- plotCounts(dds, gene = "ENSG00000164062", intgroup = "celltype", returnData=TRUE)
#d %>% View()
# can be used for ggplot
ggplot(d, aes(x = celltype, y = count, color = celltype)) +
    geom_point(position=position_jitter(w = 0.1,h = 0)) +
    geom_text_repel(aes(label = rownames(d))) +
    theme_bw() +
    ggtitle("ENSG00000164062") +
    theme(plot.title = element_text(hjust = 0.5))
```
Extract the normalized values of all the significant genes and plot a heatmap of their expression using `pheatmap()`.

```{r heatmap, message=FALSE, warning=FALSE}
normalized_counts <- counts(dds, normalized=T)[,c(10:12,4:6)]
norm_sig <- subset(normalized_counts, row.names(normalized_counts) %in% row.names(res_sig_sorted))
head(norm_sig[,1:6])
# pheatmap(norm_sig[,1:6],
#     cluster_rows = T,
#     show_rownames = F,
#     annotation = meta,
#     border_color = NA,
#     fontsize = 10,
#     scale = "row",
#     fontsize_row = 10,
#     height = 20)

```
A commonly used plot to have a global view of the expression is volcano plot; in which the log transformed adjusted p-values plotted on the y-axis and log2 fold change values on the x-axis.
```{r volcano plot, message=FALSE, warning=FALSE}


```
#Likelihood ratio test
DESeq2 also offers the Likelihood Ratio Test as an alternative when evaluating expression change across more than two levels. Genes which are identified as significant, are those that are changing in expression in any direction across the different factor levels.
There is no need for contrasts since we are not making a pair-wise comparison.
The LRT is comparing the full model to the reduced model to identify significant genes. The p-values are determined solely by the difference in deviance between the ‘full’ and ‘reduced’ model formula (not the log2 fold changes). Essentially the LRT test is testing whether the term(s) removed in the ‘reduced’ model explains a significant amount of variation in the data
```{r lrt, message=FALSE, warning=FALSE}
# which model are we interested in as reduced?
dds_lrt <- DESeq(dds, test="LRT", reduced = ~celltype + condition)
res_lrt <- results(dds_lrt)
head(res_lrt)

```
Columns relevant to the LRT test:
* baseMean: mean of normalized counts for all samples
* stat: the difference in deviance between the reduced model and the full model
* pvalue: the stat value is compared to a chi-squared distribution to generate a pvalue
* padj: BH adjusted p-values
```{r detect lrt sig genes, message=FALSE, warning=FALSE}
# padj < 0.05
sig_res_lrt <- res_lrt %>%
               data.frame() %>%
               rownames_to_column(var="gene") %>%
               as_tibble() %>%
               filter(padj < 0.05)
head(sig_res_lrt)
# Get sig gene lists
sig_lrt_genes <- sig_res_lrt %>%
                pull(gene)

length(sig_lrt_genes)

# Compare to numbers we had from Wald test
# ???

```

# Biological interpretation
## Primer

We now have an idea on how we can extract pair-wise comparisons from a multi-factor DESeq2 analysis, 
and we got a primer on comparisons beyond pair-wise comparisons. What now ?
Let's try to extract something biologically meaningful from the data.

Remember that we specified our design as:

design ~ celltype + condition + celltype:condition
```{r return design }
design
```

> **Poll 3.1**: 
> Is there a difference between specifying ~celltype*condition and ~celltype + condition + celltype:condition ?


Also remember our factors, and especially what level they have
```{r return sampleInfoFactors}
sampleInfo$celltype
sampleInfo$condition
```

> **Poll 3.2**: 
> Given our design (~celltype*condition), what comparison do we look at by specifying results(dds, contrast = c("condition", "DMSO", "TG")) ?


To go on, we have to remember that this is in essence a drug repurposing study.

A couple of other relevant notes:

 - BM and JJ are two cell lines derived from multiple myeloma patients. 
 - (alternative) splicing is affected in these patients.
 - TG003 is a drug commonly used in this disease (clk1 kinase inhibitor).
 - Amiloride is an old drug (diuretic) that is hypothesized to be a good candidate for repurposing in multiple myeloma.

## The Amiloride effect vs. the TG effect.

Let's start by assessing the difference between amiloride treated cells and TG treated cells.

Remember our coefficients:
```{r coefficients dds, message=FALSE, warning=FALSE}
resultsNames(dds)
```

### Extract AMIL vs TG  - BM cells results:

```{r extract AMILvTG - BM results, message=FALSE, warning=FALSE}
TGvAMIL <- results(dds, contrast = c('condition', 'TG', 'AMIL'), alpha = 0.05)
head( data.frame(TGvAMIL) )

#or 

TGvAMIL <- results(dds, contrast = c(0,0,0,1,0,0), alpha=0.05)
head( data.frame(TGvAMIL) )
```

> **Poll 3.3**: 
> Given our contrast c('condition', 'TG', 'AMIL'), what does a positive fold change correspond to?

Cave!
If we want to use shrinking, be careful with the normal/apegml method as lfcShrink method doesn't support all forms of contrasts.
ashr-method is a bit more versatile. A workaround is releveling your factors and rerunning DESeq again.


```{r Shrinking and contrasts: the pitfall, message=FALSE, warning=FALSE}
#TGvAMIL_shrunk <- lfcShrink(dds, contrast=c(0,0,0,1,0,0), type="apeglm") # This WONT work.
TGvAMIL_shrunk <- lfcShrink(dds, coef=c('condition_TG_vs_AMIL'), type="apeglm") # This will work.
```

### Extract AMIL vs TG  - JJ cells results:

Specifying the right contrast is not immediately clear, and in fact we have two options:

  - relevel the cellType factor for JJ cells, rerun DESeq ( !important ), and extract using the same contrast as we used for BM cells.
or
  - specify the contrast as a numerical vector corresponding to our resultsNames(dds) vector.

By now you should know how to execute option one, so let's do option two.
The effect of AMIL-TG in JJ cells can be specified (considering our resultsNames) as:
the AMIL-TG effect + the interaction term TG-JJ.
We can specify the contrast as such:

```{r extract AMILvTG - JJ results, message=FALSE, warning=FALSE}
TGvAMIL_JJ <- results(dds, contrast = c(0,0,0,1,0,1), alpha=0.05)
# Recall the contrasts:
resultsNames(dds)
```

> **Task**: We have two result objects (TGvAMIL_JJ and TGvAMIL_BM).  
> 1. Extract the information in this object to a dataframe  
> 2. Remove rows where the baseMean == 0  
> 3. Remove rows where the padj column is NA  
> 4. sort rows in the dataframe for padj (ascending, to get lowest P-values at the top).  
> Optional: If you're feeling up to it, these steps can be generalized in a function.  


```{r Clean results and return dataframes, message=FALSE, warning=FALSE}
cleanDF <- function(RESobj){
  RESdf <- data.frame(RESobj) %>%
    filter(baseMean > 0) %>%
    drop_na() %>%
    arrange(padj)
  return(RESdf)
}

TGvAMIL_JJ_cleaned <- cleanDF(TGvAMIL_JJ)
TGvAMIL_BM_cleaned <- cleanDF(TGvAMIL)

```

Our dataframes are cleaned up, and ready for further analysis. 
There is one item remaining, and that is to add the gene symbol information.
Numerous packages are available to this purpose, and the most widely known is {r} [biomArt] (https://bioconductor.org/packages/release/bioc/html/biomaRt.html)
However, since this packages queries an API, we could risk of being firewalled if we all try to query from the same IP address.
As an alternative, we can use some prebuilt genome annotation packages that make our life easier.
For human annotations, this package is called "org.Hs.eg.db". There are others available for mouse (org.Mm.eg.db), etc.

Cave! You will see that there are NA's introduced 
```{r Map ensemble IDs to gene symbols, warning = FALSE, message=FALSE}
TGvAMIL_JJ_cleaned$gene_symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(TGvAMIL_JJ_cleaned),
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")
print(paste0("JJ - NA: ", sum(is.na(TGvAMIL_JJ_cleaned$gene_symbol)), "/", nrow(TGvAMIL_JJ_cleaned), " rows" ) )
TGvAMIL_JJ_cleaned <- TGvAMIL_JJ_cleaned %>% drop_na(gene_symbol)

TGvAMIL_BM_cleaned$gene_symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(TGvAMIL_BM_cleaned),
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")
print(paste0("BM - NA: ", sum(is.na(TGvAMIL_BM_cleaned$gene_symbol)), "/", nrow(TGvAMIL_BM_cleaned), " rows" ) )
TGvAMIL_BM_cleaned <- TGvAMIL_BM_cleaned %>% drop_na(gene_symbol)
```


```{r Plot the top hits.}
# Plot Zscores for top20 hits.
pheatmap(
  counts(dds, normalized=TRUE)[head( rownames(TGvAMIL_JJ_cleaned) , n=20), c("JJ_AMIL_1",
                                                                             "JJ_AMIL_2",
                                                                             "JJ_AMIL_3",
                                                                             "JJ_TG_1",
                                                                             "JJ_TG_2",
                                                                             "JJ_TG_3")],
  labels_row=head( TGvAMIL_JJ_cleaned , n=20)$gene_symbol,
  scale = 'row',
  main='TG v AMIL - JJ'
  )

pheatmap(
  counts(dds, normalized=TRUE)[head( rownames(TGvAMIL_BM_cleaned) , n=20), c("BM_AMIL_1",
                                                                             "BM_AMIL_2",
                                                                             "BM_AMIL_3",
                                                                             "BM_TG_1",
                                                                             "BM_TG_2",
                                                                             "BM_TG_3")],
  labels_row=head( TGvAMIL_BM_cleaned , n=20)$gene_symbol,
  scale = 'row',
  main='TG v AMIL - BM'
  )
```

To look at the similarity:

```{r Create a list for use in upSet plots, message = FALSE, warning = FALSE}
upsetList <- list(
  "BM - Up" = rownames( TGvAMIL_BM_cleaned[ (TGvAMIL_BM_cleaned$log2FoldChange > 2) & (TGvAMIL_BM_cleaned$padj < 0.05),] ),
  "BM - Down" = rownames( TGvAMIL_BM_cleaned[ (TGvAMIL_BM_cleaned$log2FoldChange < -2) & (TGvAMIL_BM_cleaned$padj < 0.05),] ),
  "JJ - Up" = rownames( TGvAMIL_JJ_cleaned[ (TGvAMIL_JJ_cleaned$log2FoldChange > 2) & (TGvAMIL_JJ_cleaned$padj < 0.05),] ),
  "JJ - Down" = rownames( TGvAMIL_JJ_cleaned[ (TGvAMIL_JJ_cleaned$log2FoldChange < -2) & (TGvAMIL_JJ_cleaned$padj < 0.05),] )
  )

upset(fromList(upsetList), order.by = "freq")
```


Finally, look at two specific geneSets.
 
 - genes involved in splicing
 - genes involved in apoptosis
 
```{r KEGG pathways, eval = FALSE, message = FALSE, warning = FALSE}
print("KEGG")
# read KEGG genes
# subset DFs
# heatmap / w/ pvalues
```

 
 LRT on treatment effect.
 
```{r LRT, eval = FALSE, message = FALSE, warning = FALSE}
print("LRT")
# LRT
# explore
```
